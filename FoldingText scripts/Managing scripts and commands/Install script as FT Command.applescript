property pTitle : "Install script as FoldingText command"property pVer : "0.01"property pTextScript : "Text OSA Script"property pCompiledScript : "Compiled OSA Script"property pstrBundle : "com.foldingtext.FoldingText"property pstrCmdPath : "$HOME/Library/Application Scripts/" & pstrBundleon run	tell application id "sevs"		activate		display dialog "Use as LaunchBar/Alfred file action" & ¬			linefeed & linefeed & "or save as .app droplet and drag scripts onto droplet." buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer	end tellend runon open lstFiles	if not IsInstalled(pstrBundle) then		tell application id "sevs"			activate			display dialog "FoldingText does not appear to be installed" buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer		end tell		return	end if		if class of lstFiles is list then		tell application "Finder"			repeat with oFile in lstFiles								-- CHECK THAT THIS IS A .SCPT FILE				set strSrcPath to POSIX path of oFile				set recProps to properties of oFile				set strKind to kind of recProps				tell application id "sevs"					if strKind = pTextScript then						activate						display dialog strSrcPath & linefeed & linefeed & ¬							"is an .applescript text file." & linefeed & linefeed & ¬							"Save from Applescript Editor as a compiled script file and try again with the .scpt file" & linefeed & linefeed & ¬							"( Save As > File format > Script )" buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer						return					else						if strKind ≠ pCompiledScript then							activate							display dialog strSrcPath & linefeed & linefeed & ¬								"is not an Applescript .scpt file" & linefeed & linefeed & ¬								"Save a script from AppleScript Editor and try again with the .scpt file" & linefeed & linefeed & ¬								"( Save As > File format > Script )" buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer							return						end if					end if				end tell								-- GET A COMMAND 				set strCommand to my GetCommand(strSrcPath)				if strCommand ≠ "" then										-- AND A DESCRIPTION					set strDescription to my GetDescription(strCommand, strSrcPath)					if strCommand ≠ "" then						-- SAVE A COMMAND--DESCRIPTION.scpt copy to the folder 						my MakeFTCommand(strSrcPath, strCommand, strDescription)												-- OPEN THE FOLDER IN CASE FURTHER EDITS ARE NEEDED						set strCmd to "open " & my QuotedPath(pstrCmdPath)						do shell script strCmd						tell application "Finder" to activate					end if				end if			end repeat			tell application id "sevs"				activate				display dialog "Close and reopen FoldingText" & linefeed & "to activate new command(s)" buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer			end tell		end tell	end ifend openon MakeFTCommand(strPath, strCommand, strDescription)	-- ASSEMBLE THE NAME	set strName to strCommand & "--" & strDescription & ".scpt"		-- CHECK THAT THE  TARGET FOLDER EXISTS	if isFolder(pstrCmdPath) then	else		set strCmd to "mkdir " & QuotedPath(pstrCmdPath)		do shell script strCmd	end if		-- AND MAKE A SUITABLY NAMED COPY IN IT	set strCmd to "cp " & QuotedPath(strPath) & space & QuotedPath(pstrCmdPath & "/" & strName)	do shell script strCmdend MakeFTCommandon GetCommand(strPath)	set {strFolder, strFileName} to SplitPath(strPath)	try		tell application id "sevs"			activate			set varResponse to display dialog strPath & linefeed & linefeed & "Command name/phrase:" & ¬				linefeed & linefeed & ¬				"(will be used in lower case, can include spaces)" default answer text 1 thru -6 of strFileName ¬				buttons {"Cancel", "OK"} cancel button "cancel" default button "OK" with title pTitle & "  ver. " & pVer		end tell				return my lcase(trim(text returned of varResponse))	on error		return ""	end tryend GetCommandon GetDescription(strCommand, strPath)	try		tell application id "sevs"			set varResponse to display dialog strPath & linefeed & linefeed & ¬				"Command: " & strCommand & linefeed & linefeed & ¬				"Description:" default answer linefeed & linefeed ¬				buttons {"Cancel", "OK"} cancel button "cancel" default button "OK" with title pTitle & "  ver. " & pVer		end tell		set strDescpn to SentenceCase(trim(text returned of varResponse))		if strDescpn ends with "." then set strDescpn to text 1 thru -2 of strDescpn		return my SentenceCase(text returned of varResponse)	on error		return ""	end tryend GetDescription-- Split a Posix path into Path/Folder/ + FileNameon SplitPath(strFullPath)	set {dlm, my text item delimiters} to {my text item delimiters, "/"}	set lstParts to text items of strFullPath	set strFile to item -1 of lstParts	set strPath to ((items 1 thru -2 of lstParts) as string)	set my text item delimiters to dlm		set strCmd to "echo " & QuotedPath(strPath)	set strPath to (do shell script strCmd) & "/"	return {strPath, strFile}end SplitPathon QuotedPath(strDefaultPath)	if strDefaultPath begins with "$" then		return "\"" & strDefaultPath & "\""	else		return quoted form of strDefaultPath	end ifend QuotedPathon lcase(str)	do shell script "echo " & quoted form of str & " | tr \"[:upper:]\" \"[:lower:]\""end lcase-- First letter of each sentenceon SentenceCase(str)	set {strDelim, my text item delimiters} to {my text item delimiters, ". "}	set lst to text items of str	repeat with i from 1 to length of lst		set item i of lst to do shell script ("echo " & quoted form of (item i of lst) & " | perl -nle 'print ucfirst lc'")	end repeat	set {strSentences, my text item delimiters} to {lst as text, strDelim}	strSentencesend SentenceCaseon FileExists(strPath)	(do shell script ("test -e " & quoted form of strPath & "; echo $?")) = "0"end FileExistson IsInstalled(strCreatorCode)	try		tell application "Finder" to exists application file id strCreatorCode	on error		false	end tryend IsInstalledon isFolder(strPath)	(do shell script ("test -d " & QuotedPath(strPath) & "; echo $?")) = "0"end isFolderon trim(strText)	do shell script "echo " & quoted form of strText & " | perl -pi -e 's/^\\s+//; s/\\s+$//'"end trim