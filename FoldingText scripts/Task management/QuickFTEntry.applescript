-- Copyright (C) 2012 Robin Trew---- Permission is hereby granted, free of charge, -- to any person obtaining a copy of this software -- and associated documentation files (the "Software"), -- to deal in the Software without restriction, -- including without limitation the rights to use, copy, -- modify, merge, publish, distribute, sublicense, -- and/or sell copies of the Software, and to permit persons -- to whom the Software is furnished to do so, -- subject to the following conditions:-- *******-- The above copyright notice and this permission notice -- shall be included in ALL copies -- or substantial portions of the Software.-- *******-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, -- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES -- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. -- IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, -- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, -- TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE -- OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.property pTitle : "FoldingText Quick Entry"property pVer : "0.02"property pTaskFile : "$HOME/Library/Application Support/Notational Velocity/CurrentList.txt"property pDefaultHeader : "Inbox"-- FUNCTION-- Allows quick addition of tasks (through LaunchBar) under a particular heading in a FoldingText file-- Specifying the header:-- The header under which the task will be listed can be specified (by a case-insensitive -- partial string or regex) or chosen from a menu, if there are multiple matches.-- If no header is specified, a default header (specified by pDefaultHeader above) is used-- INSTALLATION-- Edit pTaskFile above to specify a full Posix path to an existing FoldingText file-- Use $HOME rather than ~ to specify the home folder-- Edit pDefaultHeader to the name of a header in the FoldingText file.-- This allows for quick entry of tasks without specifying a header-- Save as a .scpt on a path indexed by LaunchBar, and reindex that path-- USE-- Invoke the script with Launchbar, tap the space-bar to open a text field,-- and enter a string using ">" to separate the text and tags from the header specifier-- 	Task text [@tag ...] [ > project string ] -- Write report @tag1 @tag2 > part of heading name	[part of heading - case insensitive - menu pops up if not unique]-- Read New York Times @tag3 > /regular expression/ 	[a header expression between / will be interpreted as a regular expression]-- Buy oranges  > *										[simple asterisk to choose from menu of headings in the file]-- Discard "art of war" and run !!				 		[append to default heading, if defined]-- STANDARD LAUNCHBAR HANDLER FOR STRING PARAMETERon handle_string(strTaskLine)	Add2FT(pTaskFile, strTaskLine) -- strTaskLine = task text [tags] [ > project string ]end handle_string-- TOP LEVEL FUNCTION: PARSE TASKLINE, AND ADD GIVEN TASK AND TAGS TO SPECIFIED HEADER IN DEFAULT FILEon Add2FT(strPath, strTaskLine)	-- CHECK THAT THE FILE EXISTS	if not FileExists(strPath) then		-- REPORT THAT FILE IS UNKNOWN		display dialog "File not found:" & linefeed & linefeed & pTaskFile ¬			buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer		return	else		set {strTask, strHeader} to ParseEntry(strTaskLine)		AddLine(strPath, strHeader, strTask)	end ifend Add2FT-- ADD A TASK LINE UNDER THE SPECFIED HEADER IN THE SPECIFIED FOLDINGTEXT FILEon AddLine(strPath, strHeader, strLine)	do shell script "open -a FoldingText \"" & strPath & "\"; sleep 0.1"	tell application "FoldingText"		tell front document			-- LOOK FOR SPECIFIED HEADER (SIMPLE MATCH OR REGEX)			if strHeader starts with "/" and strHeader ends with "/" then -- interpret as regex				set lstNodes to read nodes at path "//@type=heading and matches '" & (text 2 thru -2 of strHeader) & "'"			else				if strHeader = "*" then set strHeader to "" -- simple glob: trigger choice from full menu of headers				set lstNodes to read nodes at path "//@type=heading and @line contains [i] " & quoted form of strHeader			end if						set lngNodes to length of lstNodes			if lngNodes ≠ 0 then				if lngNodes > 1 then -- MULTIPLE MATCHES → CHOOSE HEADER FROM MENU					set lngDigits to (length of (lngNodes as string))					set {lstMenu, i} to {{}, 1}					repeat with oNode in lstNodes						set end of lstMenu to my PadNum(i, lngDigits) & tab & |line| of oNode						set i to i + 1					end repeat										set varChoice to choose from list lstMenu with title pTitle & tab & pVer with prompt ¬						"Choose header:" default items {} ¬						OK button name "OK" cancel button name "Cancel" with empty selection allowed without multiple selections allowed					if varChoice = false then return missing value					set varChoice to item 1 of varChoice										set {dlm, my text item delimiters} to {my text item delimiters, tab}					set i to (first text item of varChoice) as integer					set {strID, strFullHeader} to {|id|, |line|} of item i of lstNodes					set my text item delimiters to dlm									else -- SINGLE MATCH → USE THIS HEADER					set {strID, strFullHeader} to {|id|, |line|} of item 1 of lstNodes				end if								set strItem to "- " & strLine				if strID ≠ "" then -- ADD TASK UNDER HEADER					create nodes at id strID from text strItem					my Notify("FoldingText", "FT Quick Entry", "Added task", strFullHeader & ¬						linefeed & strItem)				else -- APPEND TASK TO END OF FILE					create nodes from text strItem					my Notify("FoldingText", "FT Quick Entry", "Appended task to end of file", strItem)				end if			else				-- NO MATCHING HEADER FOUND: WARN AND EXIT				display dialog "Header matching:" & linefeed & linefeed & tab & quoted form of strHeader & linefeed & linefeed & ¬					"not found in:" & linefeed & linefeed & strPath buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVer			end if		end tell	end tellend AddLine-- SEPARATE TASK AND TAGS FROM HEADER PATTERNon ParseEntry(strTaskLine)	set {dlm, my text item delimiters} to {my text item delimiters, " > "}	set lstParts to text items of strTaskLine	if length of lstParts > 1 then		set strTask to trim((items 1 thru -2 of lstParts) as string)		set strHeader to trim(item -1 of lstParts)	else		set {strTask, strHeader} to {trim(strTaskLine), pDefaultHeader}	end if	set my text item delimiters to dlm	return {strTask, strHeader}end ParseEntryon FileExists(strPath)	set str to (do shell script ("test -e \"" & strPath & "\"; echo $?")) = "0"end FileExistson trim(strText)	do shell script "echo " & quoted form of strText & " | perl -pi -e 's/^\\s+//; s/\\s+$//'"end trim-- NOTIFY USER OF RESULTS WITH GROWL OR APPLESCRIPT DIALOGon Notify(strAppName, strProcess, strTitle, strMsg)	tell application "System Events"		set strGrowlApp to ""		repeat with oGrowlApp in {"Growl", "GrowlHelperApp"}			if (count of (every process whose name = oGrowlApp)) > 0 then				set strGrowlApp to oGrowlApp				exit repeat			end if		end repeat		if strGrowlApp ≠ "" then			set strScript to "			tell application \"" & strGrowlApp & "\"				register as application \"Houthakker scripts\" all notifications {\"" & strProcess & "\"} default notifications {\"" & strProcess & "\"} icon of application \"" & strAppName & "\"				notify with name \"" & strProcess & "\" title \"" & strTitle & "\" application name \"Houthakker scripts\" description \"" & strMsg & "\"			end tell"			strScript			run script strScript		else			activate			display dialog strMsg buttons {"OK"} default button "OK" with title pTitle & tab & pVer		end if	end tellend Notify-- LEFT PAD A DIGIT STRING WITH ZEROS (TO GET REQUIRED LENGTH)on PadNum(lngNum, lngDigits)	set strNum to lngNum as string	set lngGap to (lngDigits - (length of strNum))	repeat while lngGap > 0		set strNum to "0" & strNum		set lngGap to lngGap - 1	end repeat	strNumend PadNum